{
  parserClass="kr.jaehoyi.gdshader.parser.GDShaderParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="GDShader"
  psiImplClassSuffix="Impl"
  psiPackage="kr.jaehoyi.gdshader.psi"
  psiImplPackage="kr.jaehoyi.gdshader.psi.impl"

  elementTypeHolderClass="kr.jaehoyi.gdshader.psi.GDShaderTypes"
  elementTypeClass="kr.jaehoyi.gdshader.psi.GDShaderElementType"
  tokenTypeClass="kr.jaehoyi.gdshader.psi.GDShaderTokenType"
  
  psiImplUtilClass="kr.jaehoyi.gdshader.psi.impl.GDShaderPsiImplUtil"
  
  tokens=[
  	UNTERMINATED_STRING_CONSTANT = "Unterminated string"
  	LINE_COMMENT = "Line commnet"
  	BLOCK_COMMENT = "Block comment"
  	PP_DEFINE_LINE = "Preprocessor define line"
    PP_UNDEF_LINE = "Preprocessor undef line"
    PP_ELSE_LINE = "Preprocessor else line"
    PP_ELIF_LINE = "Preprocessor elif line"
    PP_ENDIF_LINE = "Preprocessor endif line"
    PP_IFDEF_LINE = "Preprocessor ifdef line"
    PP_IFNDEF_LINE = "Preprocessor ifndef line"
    PP_IF_LINE = "Preprocessor if line"
    PP_ERROR_LINE = "Preprocessor error line"
    PP_INCLUDE_LINE = "Preprocessor include line"
    PP_PRAGMA_LINE = "Preprocessor pragma line"
  ]
}

gdShaderFile ::= item*

item ::= top_level_declaration
	   
// Top Level Declarations
top_level_declaration ::= shader_type_declaration
		    		    | render_mode_declaration
		    		    | stencil_mode_declaration
		    		    | uniform_group_declaration
		    		    | uniform_declaration
		    		    | constant_declaration
		    		    | varying_declaration
		    		    | function_declaration
		    		    | struct_declaration

// Shader Type Declaration
shader_type_declaration ::= SHADER_TYPE shader_type_name SEMICOLON {
	methods=[ getShaderType ]
	pin=1
}
shader_type_name ::= IDENTIFIER

// Render Mode Declaration
render_mode_declaration ::= RENDER_MODE render_mode_declarator_list SEMICOLON {
	methods = [ getRenderModes ]
	pin=1
}
render_mode_declarator_list ::= render_mode_name (COMMA render_mode_name)*
render_mode_name ::= IDENTIFIER

// Stencil Mode Declaration
stencil_mode_declaration ::= STENCIL_MODE stencil_mode_declarator_list SEMICOLON {
	pin=1
}
stencil_mode_declarator_list ::= stencil_mode_name (COMMA stencil_mode_name)*
stencil_mode_name ::= IDENTIFIER | INT_CONSTANT

// Uniform Group Declaration
uniform_group_declaration ::= UNIFORM_GROUP uniform_group_name? (PERIOD IDENTIFIER)* SEMICOLON {
	pin=1
}
uniform_group_name ::= IDENTIFIER

// Uniform Declaration
uniform_declaration ::= uniform_header precision? type variable_name array_size? hint_section? (OP_ASSIGN expression)? SEMICOLON {
	pin=1
}
uniform_header ::= (GLOBAL | INSTANCE) UNIFORM | UNIFORM { pin=1 }
hint_section ::= COLON hint_list {
	pin=1
	recoverWhile=hint_section_recover
}
private hint_section_recover ::= !(SEMICOLON | OP_ASSIGN)
hint_list ::= hint (COMMA hint)*
hint ::= simple_hint
	   | range_hint
	   | enum_hint
	   | instance_index_hint
simple_hint ::= hint_identifier (COMMA hint_identifier)*
range_hint ::= HINT_RANGE PARENTHESIS_OPEN number COMMA number (COMMA number)? PARENTHESIS_CLOSE
enum_hint ::= HINT_ENUM PARENTHESIS_OPEN STRING_CONSTANT (COMMA STRING_CONSTANT)* PARENTHESIS_CLOSE
instance_index_hint ::= HINT_INSTANCE_INDEX PARENTHESIS_OPEN INT_CONSTANT PARENTHESIS_CLOSE

hint_identifier ::= HINT_DEFAULT_WHITE_TEXTURE
			      | HINT_DEFAULT_BLACK_TEXTURE
			      | HINT_DEFAULT_TRANSPARENT_TEXTURE
			      | HINT_NORMAL_TEXTURE
			      | HINT_ROUGHNESS_NORMAL_TEXTURE
			      | HINT_ROUGHNESS_R
			      | HINT_ROUGHNESS_G
			      | HINT_ROUGHNESS_B
			      | HINT_ROUGHNESS_A
			      | HINT_ROUGHNESS_GRAY
			      | HINT_ANISOTROPY_TEXTURE
			      | HINT_SOURCE_COLOR
			      | HINT_COLOR_CONVERSION_DISABLED	
			      | HINT_SCREEN_TEXTURE
			      | HINT_NORMAL_ROUGHNESS_TEXTURE
			      | HINT_DEPTH_TEXTURE
			      | FILTER_NEAREST
			      | FILTER_LINEAR
			      | FILTER_NEAREST_MIPMAP
			      | FILTER_LINEAR_MIPMAP
			      | FILTER_NEAREST_MIPMAP_ANISOTROPIC
			      | FILTER_LINEAR_MIPMAP_ANISOTROPIC
			      | REPEAT_ENABLE
			      | REPEAT_DISABLE

// Constant Declaration
constant_declaration ::= CONST precision? type constant_declarator_list SEMICOLON {
	pin=1
}

constant_declarator_list ::= constant_declarator (COMMA constant_declarator)*
constant_declarator ::= variable_name array_size? OP_ASSIGN initializer {
	pin=1
}

// Varying Declaration
varying_declaration ::= VARYING (INTERPOLATION_FLAT | INTERPOLATION_SMOOTH)? precision? type variable_name array_size? SEMICOLON {
	pin=1
}

// Local Variable Declaration
local_variable_declaration ::= precision? type local_variable_declarator_list SEMICOLON

// Variable Declarations
local_variable_declarator_list ::= local_variable_declarator (COMMA local_variable_declarator)*
local_variable_declarator ::= variable_name array_size? (OP_ASSIGN initializer)?

variable_name ::= IDENTIFIER

initializer ::= expression | initializer_list
initializer_list ::= CURLY_BRACKET_OPEN expression (COMMA expression)* CURLY_BRACKET_CLOSE

array_size ::= BRACKET_OPEN expression BRACKET_CLOSE
       
// Function Declaration
function_declaration ::= (precision? type) function_name PARENTHESIS_OPEN parameter_list? PARENTHESIS_CLOSE block {
	pin=3
}

function_name ::= IDENTIFIER

parameter_list ::= parameter (COMMA parameter)* {
	recoverWhile=parameter_list_recover
}
private parameter_list_recover ::= !(PARENTHESIS_CLOSE)
parameter ::= parameter_qualifier? precision? type (BRACKET_OPEN expression BRACKET_CLOSE)? parameter_name (BRACKET_OPEN expression BRACKET_CLOSE)? {
	pin=3
	recoverWhile=parameter_recover
}
private parameter_recover ::= !(COMMA | PARENTHESIS_CLOSE)
parameter_qualifier ::= CONST? ARG_IN | CONST | ARG_OUT | ARG_INOUT
parameter_name ::= IDENTIFIER

block ::= CURLY_BRACKET_OPEN block_body CURLY_BRACKET_CLOSE
block_body ::= statement_body* {
	recoverWhile=block_body_recover
}
private block_body_recover ::= !(CURLY_BRACKET_CLOSE) 

// Struct Declarations
struct_declaration ::= STRUCT struct_name struct_block SEMICOLON {
	pin=1
}
struct_name ::= IDENTIFIER
struct_block ::= CURLY_BRACKET_OPEN struct_member_list CURLY_BRACKET_CLOSE
struct_member_list ::= struct_member* {
	recoverWhile=struct_member_list_recover
}
private struct_member_list_recover ::= !(CURLY_BRACKET_CLOSE)
struct_member ::= precision? type struct_member_name (array_size)? SEMICOLON {
	pin=2
}
struct_member_name ::= IDENTIFIER

// Control Statements
control_statement ::= if_statement
					| for_statement
					| while_statement
					| do_while_statement
					| switch_statement
					
if_statement ::= CF_IF PARENTHESIS_OPEN expression PARENTHESIS_CLOSE statement_body else_clause? {
	pin=1
}

else_clause ::= CF_ELSE (if_statement | statement_body) {
	pin=1
}

for_statement ::= CF_FOR PARENTHESIS_OPEN (expression? SEMICOLON | local_variable_declaration) expression? SEMICOLON expression? PARENTHESIS_CLOSE statement_body {
	pin=1
}

do_while_statement ::= CF_DO statement_body CF_WHILE PARENTHESIS_OPEN expression PARENTHESIS_CLOSE SEMICOLON {
	pin=1
}

while_statement ::= CF_WHILE PARENTHESIS_OPEN expression PARENTHESIS_CLOSE statement_body {
	pin=1
}

switch_statement ::= CF_SWITCH PARENTHESIS_OPEN expression PARENTHESIS_CLOSE switch_block {
	pin=1
}
switch_block ::= CURLY_BRACKET_OPEN switch_body CURLY_BRACKET_CLOSE
switch_body ::= case_clause* {
	recoverWhile=switch_body_recover
}
private switch_body_recover ::= !(CURLY_BRACKET_CLOSE)
case_clause ::= CF_CASE expression COLON case_body | CF_DEFAULT COLON case_body {
	pin=1
}
case_body ::= statement_body*

return_statement ::= CF_RETURN expression? SEMICOLON

simple_statement ::= CF_BREAK SEMICOLON
					| CF_CONTINUE SEMICOLON
					| CF_DISCARD SEMICOLON
					
statement_body ::= statement
				 | block
				 
statement ::= control_statement
			| return_statement
			| simple_statement
			| local_variable_declaration
			| expression_statement
			| constant_declaration
			| SEMICOLON

// Expressions
expression_statement ::= expression SEMICOLON
expression ::= conditional_expr

conditional_expr ::= assign_expr (QUESTION expression COLON expression)?
assign_expr ::= logic_or_expr (assignment_operator assign_expr)?
logic_or_expr ::= logic_and_expr (OP_OR logic_and_expr)*
logic_and_expr ::= bitwise_or_expr (OP_AND bitwise_or_expr)*
bitwise_or_expr ::= bitwise_xor_expr (OP_BIT_OR bitwise_xor_expr)*
bitwise_xor_expr ::= bitwise_and_expr (OP_BIT_XOR bitwise_and_expr)*
bitwise_and_expr ::= equality_expr (OP_BIT_AND equality_expr)*
equality_expr ::= relational_expr ((OP_EQUAL | OP_NOT_EQUAL) relational_expr)*
relational_expr ::= shift_expr ((OP_LESS | OP_LESS_EQUAL | OP_GREATER | OP_GREATER_EQUAL) shift_expr)*
shift_expr ::= additive_expr ((OP_SHIFT_LEFT | OP_SHIFT_RIGHT) additive_expr)*
additive_expr ::= multiplicative_expr ((OP_ADD | OP_SUB) multiplicative_expr)*
multiplicative_expr ::= unary_expr ((OP_MUL | OP_DIV | OP_MOD) unary_expr)*
unary_expr ::= (OP_NOT | OP_BIT_INVERT | OP_ADD | OP_SUB) unary_expr | (OP_INCREMENT | OP_DECREMENT)? postfix_expr
postfix_expr ::= primary (PERIOD function_name PARENTHESIS_OPEN argument_list? PARENTHESIS_CLOSE | PERIOD struct_member_name | BRACKET_OPEN expression BRACKET_CLOSE)* (OP_INCREMENT | OP_DECREMENT)?

primary ::= literal
		  | function_call
		  | constructor_call
		  | PARENTHESIS_OPEN expression PARENTHESIS_CLOSE
		  | variable_name
{
	methods = [ isLiteral isFunctionCall isExpression isVariableName ]
}
		  
function_call ::= function_name PARENTHESIS_OPEN argument_list? PARENTHESIS_CLOSE
constructor_call ::= type (BRACKET_OPEN expression? BRACKET_CLOSE)? PARENTHESIS_OPEN argument_list? PARENTHESIS_CLOSE
argument_list ::= initializer (COMMA initializer)*

// Keywords
precision ::= PRECISION_LOW | PRECISION_MEDIUM | PRECISION_HIGH

type ::= primitive_type
       | TYPE_SAMPLER2D
       | TYPE_ISAMPLER2D
       | TYPE_USAMPLER2D
       | TYPE_SAMPLER3D
       | TYPE_ISAMPLER3D
       | TYPE_USAMPLER3D
       | TYPE_SAMPLERCUBE
       | TYPE_SAMPLERCUBEARRAY
       | TYPE_SAMPLEREXT
       | struct_name
       
primitive_type ::= TYPE_VOID
			     | TYPE_BOOL
			     | TYPE_BVEC2
			     | TYPE_BVEC3
			     | TYPE_BVEC4
			     | TYPE_INT
			     | TYPE_IVEC2
			     | TYPE_IVEC3
			     | TYPE_IVEC4
			     | TYPE_UINT
			     | TYPE_UVEC2
			     | TYPE_UVEC3
			     | TYPE_UVEC4
			     | TYPE_FLOAT
			     | TYPE_VEC2
			     | TYPE_VEC3
			     | TYPE_VEC4
			     | TYPE_MAT2
			     | TYPE_MAT3
			     | TYPE_MAT4

literal ::= TRUE
		  | FALSE
		  | FLOAT_CONSTANT
		  | INT_CONSTANT
		  | UINT_CONSTANT
		  
number ::= (OP_SUB)? FLOAT_CONSTANT
		 | (OP_SUB)? INT_CONSTANT
		 | UINT_CONSTANT

// Operators
assignment_operator ::= OP_ASSIGN | OP_ASSIGN_ADD | OP_ASSIGN_SUB | OP_ASSIGN_MUL | OP_ASSIGN_DIV 
                        | OP_ASSIGN_MOD | OP_ASSIGN_SHIFT_LEFT | OP_ASSIGN_SHIFT_RIGHT | OP_ASSIGN_BIT_AND
                        | OP_ASSIGN_BIT_OR | OP_ASSIGN_BIT_XOR
